[{"categories":null,"content":"Code Style Guide Code Style Guide Code Style Guide Beautiful docs powered by Jigsaw Give your documentation a boost with Jigsaw. Generate elegant, static docs quickly and easily. Get Started About Jigsaw Templating with Laravel's Blade engine Blade is a powerful, simple, and beautiful templating language, and now you can use it for your static sites, not just your Laravel-powered apps. Use Markdown for content-driven pages Markdown is the web\u2019s leading format for writing articles, blog posts, documentation, and more. Jigsaw makes it painless to work with Markdown content. Compile your assets using Laravel Mix Jigsaw comes pre-configured with Laravel Mix, a simple and powerful build tool. Use the latest frontend tech with just a few lines of code. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000","title":null},{"categories":null,"content":"Code Style Guide Code Style Guide 404 Page not found Need to update this page? See the Jigsaw documentation. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 25th, 2022","url":"http:\/\/localhost:8000\/404","title":null},{"categories":null,"content":"Code Style Guide | Laravel Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Laravel content to be added \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel","title":null},{"categories":null,"content":"Code Style Guide | Overview Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Overview content to be added \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/overview","title":null},{"categories":null,"content":"Code Style Guide | Navigation Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Navigation Navigation The navigation menu in the left-hand sidebar is defined using an array in navigation.php. Nested pages can be added by using the children associative array. &lt;?php \/\/ navigation.php return [ 'Getting Started' =&gt; [ 'url' =&gt; 'docs\/getting-started', 'children' =&gt; [ 'Customizing Your Site' =&gt; 'docs\/customizing-your-site', 'Navigation' =&gt; 'docs\/navigation', 'Algolia DocSearch' =&gt; 'docs\/algolia-docsearch', 'Custom 404 Page' =&gt; 'docs\/custom-404-page', ], ], 'Jigsaw Docs' =&gt; 'https:\/\/jigsaw.tighten.co\/docs\/installation', ]; \/\/ config.php 'navigation' =&gt; require_once('navigation.php'), \/\/ blade files $page-&gt;navigation \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 25th, 2022","url":"http:\/\/localhost:8000\/docs\/navigation","title":null},{"categories":null,"content":"Code Style Guide | Code Cleanliness Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Code Cleanliness Last Updated: 31 Dec 2022 \u270b Try to avoid conditionals where possible (they increase cyclomatic complexity, which in turn increases mental and technical debt). Never use\u00a0else or elseif\u00a0if you end up using a conditional. \u270b One alternative to conditionals is interpolation. Keep all code within the 80 character per line limit, except for blade files. Absolutely always keep all code under 120 characters per line. However, exceeding 80 characters can be an indication of too deeply indented code. Consider refactoring out to one or more methods. Adhere to coding styles set forth in phpcs.xml, no exceptions. Code should not have any PHPMD, PHPCS, and PHPCPD warnings. (TBD\u00a0Try not to customize the rule sets, if at all possible.) \u270b Use php artisan:make to create new objects, as these will have customized stubs that conform to our style guide. Operators all operators should be surrounded by 1 space, with the exception of operators at the beginning of the statement, such as the notoperator, in which case it does not have a preceding space: if (! $test) { \u270b if there is only a single condition in an if-statement, keep the if-statement condition portion on a single line, do not place the condition on its own line. do not use inline if-statements. Type Hinting &amp; Return Types Type hint all method parameters and return values. Type hints serve as documentation, making the code more fluent and readable. Type hints and return types prevent some logic errors from propagating, catching them as close as possible to their source. Quotes \u270b use quotes (\") first, then apostrophes (') if nesting \u270b HTML attributes should always use quotes, never apostrophes \u270b escape quotes when rendering HTML or similar inside quoted strings: $test = \"&lt;a href=\\\"test.html\\\"&gt;test&lt;\/a&gt;\"; Why \ud83d\udc49 Quoted strings can be sorted. \ud83d\udc49 Reduced mental load when reading code that has nested quotes. \ud83d\udc49 Adherence to HTML5 standards. Conditionals use ternary operators instead of if statements where possible \u270b combine sequential conditions that have the same result \u270b use mapping arrays instead of multiple if-statements when inspecting different values of the same variable \u270b for conditions that consist of multiple conditions, place each condition on its own line with the operator preceding the condition Arrays \u270b always use data_get() to access arrays, instead of accessing their elements directly. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/code-cleanliness","title":null},{"categories":null,"content":"Code Style Guide | Classes Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Classes Last Updated: 31 Dec 2022 References Use Statements Use statements should be ordered alphabetically. Instantiation \u270b Where possible, classes should be injected via the constructor, allowing resolution from the CoI. Never user helper methods, or manual resolution via the app(\"...\") helper. Introspection and Type Casting \u270b Avoid introspection (checking the type of the class to determine the outcome of a condition). \u270b Avoid type casting. Both imply that logic should be encapsulated or refactored, likely resulting in rearranging or creation of classes. Final or Abstract, Never Neither Final classes cannot be extended. They are the final version of that class. Abstract classes need to be extended, and cannot be used alone. \u270b Avoid open-ended classes that are neither final nor abstract. Since you control the code, and it is unlikely to be used randomly by anyone else free-standing, and class that is not abstract should by default be final. Mutability \ud83e\udd14 Classes should be immutable. If something is changed, they should return a new instance with the changed values. (Does this even make since in a Laravel context? I think this really only comes into play for Value Objects that are not models.) Naming Name classes after what they are, and not what they do. For example, the following is correct, and the later not so much: class Name { private $firstName; private $lastName; function print() { return \"{$this-&gt;firstName} {$this-&gt;lastName}\"; } } class NamePrinter { private $firstName; private $lastName; function print() { return \"{$this-&gt;firstName} {$this-&gt;lastName}\"; } } Contracts (Interfaces) Contracts aim to loosen coupling of objects in an application. It is important to remember that coupling is shifted from concrete implementations to abstract contracts (which have no logic, but only specify method interfaces). Contracts are not always necessary. \u270b They should be used with any class that is used in dependency injection or inversion of control containers. This lets us easily switch out implementations, especially in third-party-packages that might require some customization. Statics Avoid static classes. Classes are intended to be instantiated and be identifiable. Static classes do not have an identity are are not true objects, thus are a stow-away from the procedural era. Further, static classes and methods are little more than modern equivalents of GOTO statements, procedural in nature. OOP goes beyond that, the object is the defining principle, not the code. Static classes and methods are a crutch used to think procedurally under the guise of seeming object-oriented. We want our classes to be declarative, not imperative.** From wikipedia: Declarative programming is a programming paradigm\u2014a style of building the structure and elements of computer programs\u2014that expresses the logic of a computation without describing its control flow. Imperative programming is a programming paradigm that uses statements that change a program&#39;s state. > In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates. Static classes consisting of collections of static methods, also known as utility classes, are nothing more than a bunch of non-OOP helper methods grouped together. Constructors \u270b Prefer many constructors of many public methods, when possible. \u270b Use one primary constructor, along with multiple secondary (named) constructors that all make use of the primary constructor. \u270b Constructors should not include any functionality or logic, but merely assign values to object properties. If logic needs to be performed, this is an indication that the information passed in should actually be another object. The reason behind this is that any code in the constructor will be parsed every time an object is created, regardless if it is necessary or not. That can&#39;t be optimized. Instead of only assignments are handled in constructors, optimization can be controlled, and only the necessary code performed. Properties \u270b Keep classes to fewer than 4 properties where possible (Models are the exception). \u270b Avoid classes that do not encapsulate any data. \ud83e\udd14 Avoid public properties where possible. Class properties should only be set through constructors and manipulated through methods. (Are getters and settings preferable over public properties -- what dangers are there to consider? What is the underlying reason this is considered such a bad thing?) \u270b Avoid setting properties to null. (And conversely avoid null-checks.) Methods \u270b Name methods according to what they return. Their names should be self-documenting. \u270b Methods that perform an action should be a verb, and not return anything. \u270b Methods that return objects should be nouns and named after the object they return (they can be prefixed with adjectives that help better describe the object being returned). \u270b Consider method names that are actions, but where an object is returned, like save(). In those cases, instead of returning null, return the object instance instead. \u270b Methods should only return one type of data, never mixed. \u270b Methods should have a declared parameter list, and not use a dynamic one (exceptions exist of course for magic methods). Getters and Setters \u270b Do not use getters and setters, other than the special methods used in models (getPropertyAttribute() and setPropertyAttribute($value)). \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/classes","title":null},{"categories":null,"content":"Code Style Guide | Routes Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Routes Last Updated: 31 Dec 2022 \u2705 Do \u270b use resource routes that point to controllers. \u26d4\ufe0f Do Not \u270b use closures in routes, as they cannot be cached in php artisan route:cache. APIs \u270b API routes should be within an API route namespace. \u270b API routes should use resource controllers. \u270b API route controllers should be named after the model they act on. \u270b API route controller methods should implement the restful naming scheme. \u270b API route controllers should only be responsible for a single model. Views \u270b View routes should have no namespace. \u270b View routes should use resource controllers. \u270b View route controllers should be named after the blade view folder they are responsible for. \u270b View route controller methods should implement the restful naming scheme. \u270b View route controllers should only be responsible for a single model, but responsible for all views that pertain to that model, for example: \/resources\/views\/reports\/index.blade.php \/resources\/views\/reports\/create.blade.php \/resources\/views\/reports\/show.blade.php etc... \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/routes","title":null},{"categories":null,"content":"Code Style Guide | Blade Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Blade Last Updated: 31 Dec 2022 Directives \u270b All blade directives should have a space between the directive and the parameters, mirroring the way PSR2 handles the equivalent PHP statements (if, for, etc.): @errors () \u270b Directives should be surrounded by blank lines, unless they are directly nested in other blade directives: &lt;div&gt; @foreach ($items as $item) &lt;div&gt; @foreach ($subItems as $subItem) @can (\"update\", $subItem) &lt;div&gt;Update&lt;\/div&gt; @endcan @endforeach &lt;\/div&gt; @endforeach &lt;\/div&gt; HTML \u270b Each HTML tag should be on its own line: &lt;h1&gt;Header&lt;\/h1&gt; &lt;span&gt;test&lt;\/span&gt; &lt;a&gt;test&lt;\/a&gt; \u270b All attributes of an HTML tag should be on their own line, indented, and in alphabetical order: &lt;div class=\"p-0 m-0\" wire:click=\"submit\" x-data=\"{}\" &gt; \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/blade","title":null},{"categories":null,"content":"Code Style Guide | Testing Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Testing Last Updated: 31 Dec 2022 \u270b Always write unit and integration tests, testing for success and failure for each scenario. \ud83e\udd14 Only test public methods of classes. \u270b Write tests so that they cover all protected and private methods of the class, accessed through the public methods. If there are non-public methods that are not covered, they are either inaccessible, or the tests are comprehensive enough. If they are inaccessible, those methods should be removed. \u270b Tests should document the functionality of classes and their methods. \u270b Mock any external interfaces you do not control, and test for both successes and failures. \u270b Do not mock classes that you control. Databases Do not use SQLite for testing if: - you are using JSON fields - require exact float value calculations based on decimal fields - have table alterations in your migrations - if you have raw queries which manipulate dates Unit Tests \u270b Write unite tests before implementing classes (only implement classes, never procedural code). \u270b When starting an app, start where you would start with writing code. The first test does not have to be elegant, or even correct. The most important thing is just to get started. \u270b Always do Red\/Green\/Refactor TDD. This means writing tests for the code you would like to see in an optimal world. Then make the failing test pass using the minimum amount of code. Write another test to expand on the first test, which again makes the existing code fail. Refactor your code to make the second test pass. Rinse and repeat until you have the minimum necessary functionality for your MVP (minimum viable product). \u270b During the red\/green\/refactor process, keep in mind that you need to develop from two different perspectives: When writing tests, keep the larger picture of the application and business domain in mind. When writing code to satisfy tests, only think about the test that needs to be satisfied. DO NOT THINK ABOUT BUSINESS LOGIC, ONLY FOCUS ON MAKING TESTS GREEN. \u270b Never add code that wont be used. \u270b Remove any code that is not used. \u270b Use cyclomatic complexity as a guide for the number of tests needed to achieve full test coverage of your code. \u270b As your tests get more specific, your code should become more generic. \u270b Goal of tests is to get as quickly as possible to &quot;Shameless Green&quot;, which means that no matter how ugly your code is, it satisfies all tests, thus is &quot;green&quot;. \u270b One of the principles of Shameless Green is that code is written for understanding, rather than extreme adherence to any and all patterns. The human is the focus. \u270b Consider Robert Martin&#39;s Transformation Priority Premise (https:\/\/8thlight.com\/blog\/uncle-bob\/2013\/05\/27\/TheTransformationPriorityPremise.html) when writing functional code to keep code complexity at a minimum. Try to opt for the highest ranked option. \u270b Abstract logic into methods only if they are used multiple times. Otherwise this might introduce mental debt and increase code complexity. \u270b Consider waiting to dry out duplicated code until after a few tests cover it. This way the correct abstraction might reveal itself, rather than prematurely abstracting it out incorrectly. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/testing","title":null},{"categories":null,"content":"Code Style Guide | Config &amp; Environment Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Config &amp; Environment Last Updated: 31 Dec 2022 .env \u2705 Do \u270b Store sensitive settings (passwords, API keys, etc.) in the\u00a0.env\u00a0file. \u270b Always assign env variables to config properties in the config file that is most appropriate (or create a new config file it that makes more sense). \u270b Always refer to the config variable in your code, never reference\u00a0env('xxxxx', 'abc)\u00a0outside of config files. \u26d4\ufe0f Do Not \u270b commit the\u00a0.env\u00a0file to version control (Git). \u270b use the\u00a0env()\u00a0command outside of config files, as it calls the cached config values, and not the actual values in the\u00a0.env\u00a0file. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/config-env","title":null},{"categories":null,"content":"Code Style Guide | Eloquent Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Eloquent Last Updated: 31 Dec 2022 Databases \u270b Do not use SQLite if: you are using JSON fields require exact float value calculations based on decimal fields have table alterations in your migrations if you have raw queries which manipulate dates Queries \u270b Always write queries based on models. \u270b Queries can be optimized using various methods like toBase(), etc. \u270b Don't use model attributes for filtering, instead use where clauses or for complex queries scopes. \u270b Don't use the update() or mass manipulation methods, as they do not trigger model events to be thrown. Factories to be added Migrations \u270b Each table should have its own migration file. \ud83e\udd14 Migrations should only change the database schema, and not manipulate data, unless directly necessary for the migration to run. \u270b Migrations should contain the definitive table definition in the up method, and only drop the table in the down method. \ud83e\udd14 Migrations should not be used to alter database structures, as this will prevent testing using in-memory SQLite databases. (See Seeders for this.) Primary Keys \u270b All primary keys should be defined as\u00a0$table-&gt;id(); or $table-&gt;uuid()-&gt;primary();. Foreign Keys \u270b Foreign keys should be set on all fields that refer to another table. \u270b Foreign key fields should be defined as\u00a0$table-&gt;foreignIdFrom(Model::class). Try to avoid manually naming the FK, instead let Laravel generate the name. This ensures consistent and predictable naming across the board. onDelete() \u270b Use\u00a0CASCADE\u00a0when the current table record should be deleted if the referring record is deleted. \u270b Use\u00a0SET NULL\u00a0when the current table record should be preserved, even if the referring record is deleted. If the foreign key field is nullable you should use\u00a0SET NULL. \u270b Use\u00a0RESTRICT\u00a0when the deletion of the referring record should be prevented if the current record exists. onUpdate() \u270b This should almost always be set to\u00a0CASCADE, meaning if the primary key of the referring record changes, this foreign key will update to retain the relationship. Seeders \u270b Never reference other records by their primary key, if the key is not semantic. \u270b Always seed only one model per seeder. \u270b Always use models to seed, so that any reactivity in Laravel can be triggered. \u270b Write seeders to only seed if the record does not already exist, so that seeders can be run multiple times without error. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/eloquent","title":null},{"categories":null,"content":"Code Style Guide | Controllers Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Controllers Last Updated: 31 Dec 2022 Purpose Controllers serve only two purposes: 1. Process a specific request, handled by a request object (see below). 2. Return an appropriate response, handled by a response object (see below). Controllers should contain no business logic. Instead, various types of business logic should be extracted out to: - \u270b form submission processing should be extracted to Form Request objects. Parsing of input should be done in the process() method on the Form Request object. - \u270b JSON responses should be extracted to Resource objects. - \u270b other business logic should be extracted to Action (or similar) objects. Structure \u270b Controllers should only contain RESTful methods. If additional methods seem to be needed, a new RESTful controller with an appropriate name should be created to satisfy that need. Single-Method Controllers \u270b If the controller only has a single method, use __invoke(). &lt;?php namespace App\\Http\\Controllers; use Illuminate\\View\\View; class WelcomeController extends Controller { public function __invoke() : View { return view('welcome'); } } Request Objects \u270b All reuqest object should check if the user is authorized to perform the requested operation. \u270b All controller methods that accept data should validate the incoming data using Request objects \u270b All controller methods that accept data should process the incoming data in a process() method that returns whatever object necessary to continue the logic in the controller method. For example: public function store(CreateReport $request) : RedirectResponse { $search = $request-&gt;process(); return redirect()-&gt;route('reports.show', ['addressSlug' =&gt; $search-&gt;address-&gt;slug]); } Response Objects \u270b Resource objects should be utilized to build up and return all data and objects required by the view to the view. &lt;?php namespace App\\Http\\Controllers\\Reports; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\Api\\Reports\\Event as Request; use App\\Http\\Responses\\Reports\\Events\\Csv; use Illuminate\\Contracts\\Support\\Responsable; class Event extends Controller { public function index(Request $request) : Responsable { return new Csv( $request-&gt;process(), 'CEEd Events Report.csv' ); } } &lt;?php namespace App\\Http\\Responses\\Reports\\Events; use App\\Http\\Resources\\BaseResourceCollection; use Illuminate\\Contracts\\Support\\Responsable; use Illuminate\\Http\\Response; use League\\Csv\\Writer; use SplTempFileObject; class Csv implements Responsable { protected $downloadFilename; protected $events; public function __construct( BaseResourceCollection $events, string $downloadFilename ) { $this-&gt;downloadFilename = $downloadFilename; $this-&gt;events = $events; } \/** * @SuppressWarnings(PHPMD.StaticAccess) * @SuppressWarnings(PHPMD.UnusedFormalParameter) *\/ public function toResponse($request) : Response { $csv = Writer::createFromFileObject(new SplTempFileObject); $csv-&gt;insertOne([ 'Season', 'Starts At', 'Ends At', 'Program', 'Venue', 'Moderators', 'Musicians', ]); $this-&gt;events-&gt;each(function ($event) use ($csv) { $csv-&gt;insertOne([ $event-&gt;seasonName, $event-&gt;starts_at, $event-&gt;ends_at, $event-&gt;programName, $event-&gt;venueName, $event-&gt;moderators-&gt;pluck('name')-&gt;implode(', '), $event-&gt;musicians-&gt;pluck('name')-&gt;implode(', '), ]); }); $headers = [ 'Content-Type' =&gt; 'text\/csv; charset=UTF-8', 'Content-Disposition' =&gt; \"attachment; filename=\\\"{$this-&gt;downloadFilename}\\\"\", ]; return response((string)$csv, 200, $headers); } } \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/controllers","title":null},{"categories":null,"content":"Code Style Guide | Models Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Models Last Updated: 31 Dec 2022 Eager Loading \u270b Avoid eager loading relationships in the protected $with = []; variable as this could lead to data bloat. \u270b Try to explicitly load relationships at the point they are used using the with() method on the eloquent query. Organization List use classes in alphabetical order. List the public, protected, and private properties, each group in alphabetical order. List relationship methods in alphabetical order. List getter and setter methods in alphabetical order. List persistence methods in alphabetical order. List protected methods in alphabetical order. List private methods in alphabetical order. List magic methods in alphabetical order. Persistence Methods \u270b Laravel models are the de-facto persistence repository, especially in eloquent. Do not create repository classes. \ud83e\udd14 Do not use the generic eloquent CRUD methods save(), update(), create(), delete(), etc. outside of the model. Instead create descriptive methods that explain exactly what is happening. This decouples the business domain from the persistence domain of the app, as well as makes code so much more humanly readable. For instance: instead of $user-&gt;save() create a method that handles a specific situation, like $agent-&gt;addListingInfo($listingInfo); and then handle all the data parsing and assignment in the method, at the end of which $this-&gt;save() is called to persist the changes. This pattern is not a Repository pattern, but instead an adaptation thereof for Laravel models. Laravel models already implement the repository patter in how they are build on top of Eloquent, so splitting out each model into multiple single-use-traits is an effort to maintain organization, while the other rules enforce the repository pattern of the model throughout the code-base. The benefits of this guide go deep beneath the surface, and at first glance may not be apparent: centralized place of maintenance in the attribute and query traits. deep performance optimization via centralized caching in the traits. This automatically ensures that relationship references are cached as well, for example when looping over a relationship collection. reduced technical dept, as queries and custom attributes are all contained in known centralized traits. This makes maintenance much easier when fixing or optimizing queries, as it is no longer necessary to inspect your entire codebase. reduced visual dept in models, as the custom parts are separated out into traits, keeping the model itself lean and to the point. adoption of better patterns: separating and centralizing queries helps DRY up your code, as well as force you to think more about how each query works and discover areas it can be optimized, by pulling it out of context, and looking at it on its own, without being distracted by the domain logic surrounding it. Structure \u270b All attribute methods should be extracted to an Attributes trait. \u270b All query methods should be extracted to traits: App |-Traits | |-Attributes | | \\-Book | | | \\-Queries | \\-Book | |-BaseModel \\-Book &lt;?php namespace App; use Illuminate\\Cache\\TaggableStore; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Support\\Collection; use Illuminate\\View\\View; use Laravel\\Scout\\Searchable; abstract class BaseModel extends Model { use Searchable; public static function boot() { parent::boot(); static::created(function () { self::flushCache(); }); static::deleted(function () { self::flushCache(); }); static::saved(function () { self::flushCache(); }); static::updated(function () { self::flushCache(); }); } public function cache(array $additionalTags = []) : View { if (cache()-&gt;getStore() instanceof TaggableStore) { $tags = array_push($additionalTags, str_slug(self::class)); $cache = $cache-&gt;tags($tags); } return $cache; } public static function flushCache() { cache()-&gt;tags([str_slug(self::class)]) -&gt;flush(); } } &lt;?php namespace App; use App\\Traits\\Attributes\\Contact as Attributes; use App\\Traits\\Queries\\Contact as Queries; use Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany; class Contact extends BaseModel { use Attributes; use Queries; protected $appends = [ 'searchKey', 'searchUrl', ]; protected $fillable = [ 'name', 'title', 'work_phone', 'mobile_phone', 'work_email', 'private_email', ]; public function contactTypes() : BelongsToMany { return $this-&gt;belongsToMany(ContactType::class); } } &lt;?php namespace App\\Traits\\Attributes; trait Contact { public function getGravatarAttribute() : string { $defaultAvatar = 'https:\/\/www.gravatar.com\/avatar\/?d=mm'; $workAvatar = 'https:\/\/www.gravatar.com\/avatar\/' . md5(strtolower(trim($this-&gt;work_email))) . '?d=mm'; $privateAvatar = 'https:\/\/www.gravatar.com\/avatar\/' . md5(strtolower(trim($this-&gt;private_email))) . '?d=mm'; if (md5(file_get_contents($workAvatar)) !== md5(file_get_contents($defaultAvatar))) { return $workAvatar; } if (md5(file_get_contents($privateAvatar)) !== md5(file_get_contents($defaultAvatar))) { return $privateAvatar; } return $defaultAvatar; } public function getSearchKeyAttribute() : string { return $this-&gt;name; } public function getSearchUrlAttribute() : string { return route('contacts.show', $this-&gt;getKey()); } } &lt;?php namespace App\\Traits\\Queries; use Illuminate\\Support\\Collection; trait Contact { public function getAll() : Collection { return cache()-&gt;tags([$this-&gt;classSlug]) -&gt;rememberForever(\"contact-{$this-&gt;id}-getAll\", function () { return $this-&gt;orderBy('name')-&gt;get(); }); } public function getByTypes(array $types) : Collection { $key = implode('-', $types); return cache()-&gt;tags([$this-&gt;classSlug, 'contact-type']) -&gt;rememberForever(\"contact-{$this-&gt;id}-getByTypes-{$key}\", function () use ($types) { return $this-&gt;with(['contactTypes' =&gt; function ($query) use ($types) { $query-&gt;whereIn('title', $types); }]) -&gt;orderBy('name') -&gt;get(); }); } } Eloquent Queries \ud83e\udd14 All Eloquent queries should be processed in dedicated methods within the queries trait of the model. The default getter methods provided by Eloquent should not be used anywhere outside of the model or its traits, with the exception of the following: find() findOrFail() Relationship Properties \u270b Do not query relationship properties on models directly. Instead expose the relationship property as a dynamic property in the model itself. This allows you to provide a default if the relationship does not exist, as well as limits interdependence of models to only the models themselves, and not through your code. For example, instead of $book-&gt;author-&gt;name, create a model attribute called authorName, then call that as $book-&gt;authorName in your code: &lt;?php namespace App; use App\\Traits\\Attributes\\Book as Attributes; class Book extends Model { use Attributes; public function author() : HasOne { return $this-&gt;hasOne(Author::class); } } &lt;?php namespace App\\Traits\\Attributes; trait Book { public function getAuthorNameAttribute() : string { return $this-&gt;author-&gt;name ?? ''; } } Naming Conventions Properties or Methods with Certain Return Types \u270b boolean properties should start with is..., indicating state. \u270b boolean properties or methods that check if a certain condition is true should be named has&lt;Condition in past tense&gt;. Query Methods \u270b methods returning a single instance should be prefixed with find followed by the name of the model instance it returns, for example -&gt;findUserByName(string $name). \u270b methods returning a collection of instances should be prefixed with get followed by the name of the model instances is returns, for example -&gt;getUsersByType(string $type). Caching \u270b Caching should only be done using tags named after the model, and any specific parameters that make that query unique. Cache tags should be flushed when the corresponding model gets updated, saved, or deleted, so that subsequent responses will incorporate the changes. \ud83e\udd14 All queries in the model's query trait should be cached, as well those in attribute methods that access the database directly, and not through an already cached model query. \ud83e\udd14 Cached queries should be cached forever by default. However, if they incorporate timestamps or other temporal conditions, a sensible timeout should be set, depending on their use-case, typically between 1 and 15 minutes. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/models","title":null},{"categories":null,"content":"Code Style Guide | Patterns Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Patterns Last Updated: 31 Dec 2022 NULL-Objects \u270b Avoid the use of\u00a0null, both as a negative return value from a method, but also as default parameters. \u270b Instead of\u00a0null, use empty classes of the same type expected to be returned from methods (see NULL-Objects section). \u270b Do not use null-objects as a substitute for using\u00a0null\u00a0for negative results (btw, don't use\u00a0null\u00a0anywhere in code, as it is semantically void). Instead, add a\u00a0__toString()\u00a0method that returns an empty string for empty models, and non-empty value for valid objects. For example: public function __toString() { return \"{$this-&gt;getPrimaryKey()}\"; } This has the following benefits: Less cluttered code by eliminating noisy null-object classes (which serve no other purpose than to eliminate null-checks). Ease of maintenance. Adherence to single responsibility principle, in that a method only returns a single type of data. DRY (Don't Repeat Yourself) \u270b Do not apply the dry principle to code that deals with content, or even content itself. \u270b Apply DRY only to code that deals with logic. \u270b If you find wet code, but it doesn't appear that it can be dried out, you might have an architectural flaw. Restructuring or refactoring your classes could help. \u270b Only start drying out your code if you actually have duplication. \u270b DO NOT dry out code that isn't duplicated, as this leads to premature abstraction, and is almost certain to introduce both mental and technical debt. SOLID to be added Collections \u270b Use collections for all the things. \ud83e\udd14 Consider using classes as collection transformers: is there any intent to use more of magic method\u00a0__invoke\u00a0in future versions of Laravel? I found an interesting possibly to try things like:\u00a0$collection->map(new MyModelTransformer()); \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/patterns","title":null},{"categories":null,"content":"Code Style Guide | Livewire Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Livewire Last Updated: 31 Dec 2022 Components \u270b Each livewire component needs to have a wire:key attribute that is immutable across page refreshes, but unique enough so that it never will conflict with another livewire component. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/livewire","title":null},{"categories":null,"content":"Code Style Guide | Classes Code Style Guide Overview Laravel Blade Classes Code Cleanliness Config &amp; Environment Controllers Eloquent Exceptions Livewire Models Patterns Routes Testing Classes Last Updated: 31 Dec 2022 \u270b Catch errors and exceptions as soon as possible. Use type hinting and return types as one aspect toward achieving this. \u270b This is currently a manual process for which we don't have a linter (yet). \ud83e\udd14 This is currently under consideration, but not enforced. &copy; 2022 Valmar Holdings . All rights reserved.","date":"Dec 31st, 2022","url":"http:\/\/localhost:8000\/docs\/laravel\/exceptions","title":null}]