[{"categories":null,"content":"Docs Starter Template Docs Starter Template Docs Starter Template Beautiful docs powered by Jigsaw Give your documentation a boost with Jigsaw. Generate elegant, static docs quickly and easily. Get Started About Jigsaw Templating with Laravel's Blade engine Blade is a powerful, simple, and beautiful templating language, and now you can use it for your static sites, not just your Laravel-powered apps. Use Markdown for content-driven pages Markdown is the web\u2019s leading format for writing articles, blog posts, documentation, and more. Jigsaw makes it painless to work with Markdown content. Compile your assets using Laravel Mix Jigsaw comes pre-configured with Laravel Mix, a simple and powerful build tool. Use the latest frontend tech with just a few lines of code. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide","title":null},{"categories":null,"content":"Docs Starter Template Docs Starter Template 404 Page not found Need to update this page? See the Jigsaw documentation. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/404","title":null},{"categories":null,"content":"Docs Starter Template | Getting Started Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Getting Started This is a starter template for creating a beautiful, customizable documentation site for your project with minimal effort. You\u2019ll only have to change a few settings and you\u2019re ready to go. Configuration As with all Jigsaw sites, configuration settings can be found in config.php; you can update the variables in that file with settings specific to your project. You can also add new configuration variables there to use across your site; take a look at the Jigsaw documentation to learn more. \/\/ config.php return [ 'baseUrl' =&gt; 'https:\/\/my-awesome-jigsaw-site.com\/', 'production' =&gt; false, 'siteName' =&gt; 'My Site', 'siteDescription' =&gt; 'Give your documentation a boost with Jigsaw.', 'docsearchApiKey' =&gt; '', 'docsearchIndexName' =&gt; '', 'navigation' =&gt; require_once('navigation.php'), ]; Tip: This configuration file is also where you\u2019ll define any \"collections\" (for example, a collection of the contributors to your site, or a collection of blog posts). Check out the official Jigsaw documentation to learn more. Adding Content You can write your content using a variety of file types. By default, this starter template expects your content to be located in the source\/docs folder. If you change this, be sure to update the URL references in navigation.php. Read more about navigation. The first section of each content page contains a YAML header that specifies how it should be rendered. The title attribute is used to dynamically generate HTML title and OpenGraph tags for each page. The extends attribute defines which parent Blade layout this content file will render with (e.g. _layouts.documentation will render with source\/_layouts\/documentation.blade.php), and the section attribute defines the Blade \"section\" that expects this content to be placed into it. --- title: Navigation description: Building a navigation menu for your site extends: _layouts.documentation section: content --- Read more about Jigsaw layouts. Adding Assets Any assets that need to be compiled (such as JavaScript, Less, or Sass files) can be added to the source\/_assets\/ directory, and Laravel Mix will process them when running npm run dev or npm run prod. The processed assets will be stored in \/source\/assets\/build\/ (note there is no underscore on this second assets directory). Then, when Jigsaw builds your site, the entire \/source\/assets\/ directory containing your built files (and any other directories containing static assets, such as images or fonts, that you choose to store there) will be copied to the destination build folders (build_local, on your local machine). Files that don't require processing (such as images and fonts) can be added directly to \/source\/assets\/. Read more about compiling assets in Jigsaw using Laravel Mix. Building Your Site Now that you\u2019ve edited your configuration variables and know how to customize your styles and content, let\u2019s build the site. # build static files with Jigsaw .\/vendor\/bin\/jigsaw build # compile assets with Laravel Mix # options: dev, prod npm run dev &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/getting-started","title":null},{"categories":null,"content":"Docs Starter Template | Customizing Your Site Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Customizing Your Site Styles This starter template comes pre-loaded with Tailwind CSS, a utility CSS framework that allows you to customize and build complex designs without touching a line of CSS. There are also a few base Sass files in the \/source\/_assets\/sass folder, set up with the expectation that you can add any custom CSS into _documentation.scss. You can re-work the architecture of the Sass includes any way you\u2019d like; just make sure to keep the @tailwind references in your final files. \/\/ source\/_assets\/sass\/main.scss @tailwind preflight; @tailwind components; \/\/ Code syntax highlighting, \/\/ powered by https:\/\/highlightjs.org @import '~highlight.js\/styles\/a11y-light.css'; @import 'base'; @import 'navigation'; @import 'documentation'; @tailwind utilities; Typography Styles Here\u2019s a quick preview of what some of the basic type styles will look like in this starter template: h1 Heading h2 Heading h3 Heading h4 Heading h5 Heading h6 Heading The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog class Foo extends bar { public function fooBar() { \/\/ } } &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/customizing-your-site","title":null},{"categories":null,"content":"Docs Starter Template | Algolia DocSearch Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Algolia DocSearch This starter template includes support for DocSearch, a documentation indexing and search tool provided by Algolia for free. To configure this tool, you\u2019ll need to sign up with Algolia and set your API Key and index name in config.php. Algolia will then crawl your documentation regularly, and index all your content. Get your DocSearch credentials here. \/\/ config.php return [ 'docsearchApiKey' =&gt; '', 'docsearchIndexName' =&gt; '', ]; Once the docsearchApiKey and docsearchIndexName values are set in config.php, the search field at the top of the page is ready to use. To help Algolia index your pages correctly, it's good practice to add a unique id or name attribute to each heading tag (&lt;h1&gt;, &lt;h2&gt;, etc.). By doing so, a user will be taken directly to the appropriate section of the page when they click a search result. Adding Custom Styles If you'd like to customize the styling of the search results, Algolia exposes custom CSS classes that you can modify: \/* Main dropdown wrapper *\/ .algolia-autocomplete .ds-dropdown-menu { width: 500px; } \/* Main category (eg. Getting Started) *\/ .algolia-autocomplete .algolia-docsearch-suggestion--category-header { color: darkgray; border: 1px solid gray; } \/* Category (eg. Downloads) *\/ .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column { color: gray; } \/* Title (eg. Bootstrap CDN) *\/ .algolia-autocomplete .algolia-docsearch-suggestion--title { font-weight: bold; color: black; } \/* Description description (eg. Bootstrap currently works...) *\/ .algolia-autocomplete .algolia-docsearch-suggestion--text { font-size: 0.8rem; color: gray; } \/* Highlighted text *\/ .algolia-autocomplete .algolia-docsearch-suggestion--highlight { color: blue; } For more details, visit the official Algolia DocSearch documentation. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/algolia-docsearch","title":null},{"categories":null,"content":"Docs Starter Template | Overview Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/overview","title":null},{"categories":null,"content":"Docs Starter Template | Navigation Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Navigation The navigation menu in the left-hand sidebar is defined using an array in navigation.php. Nested pages can be added by using the children associative array. &lt;?php \/\/ navigation.php return [ 'Getting Started' =&gt; [ 'url' =&gt; 'docs\/getting-started', 'children' =&gt; [ 'Customizing Your Site' =&gt; 'docs\/customizing-your-site', 'Navigation' =&gt; 'docs\/navigation', 'Algolia DocSearch' =&gt; 'docs\/algolia-docsearch', 'Custom 404 Page' =&gt; 'docs\/custom-404-page', ], ], 'Jigsaw Docs' =&gt; 'https:\/\/jigsaw.tighten.co\/docs\/installation', ]; \/\/ config.php 'navigation' =&gt; require_once('navigation.php'), \/\/ blade files $page-&gt;navigation &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/navigation","title":null},{"categories":null,"content":"Docs Starter Template | Custom 404 Page Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Custom 404 Page This starter template includes a custom 404 Not Found error page, located at \/source\/404.blade.php. To preview the 404 page, you can visit \/404 in your browser. &lt;!-- source\/404.blade.php --&gt; @extends('_layouts.master') @section('body') &lt;div class=\"flex flex-col items-center mt-32 text-gray-700\"&gt; &lt;h1 class=\"text-6xl leading-none mb-2\"&gt;404&lt;\/h1&gt; &lt;h2 class=\"text-3xl\"&gt;Page not found&lt;\/h2&gt; &lt;hr class=\"block w-full max-w-lg mx-auto my-8 border\"&gt; &lt;p class=\"text-xl\"&gt;Need to update this page? See the &lt;a title=\"404 Page Documentation\" href=\"\/docs\/404\"&gt; documentation here&lt;\/a&gt;.&lt;\/p&gt; &lt;\/div&gt; @endsection Depending on where your site is hosted, you may need to configure your server to use the custom 404 page. For more details, visit the Jigsaw documentation about configuring a custom 404 page. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/custom-404-page","title":null},{"categories":null,"content":"Docs Starter Template | Code Cleanliness Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Quotes use quotes (\") first, then apostrophes (') if nesting HTML attributes should always use quotes, never apostrophes escape quotes when rendering HTML or similar inside quoted strings $test = \"&lt;a href=\\\"test.html\\\"&gt;test&lt;\/a&gt;\"; Why \ud83d\udc49 Quoted strings can be sorted. \ud83d\udc49 Reduced mental load when reading code that has nested quotes. \ud83d\udc49 Adherence to HTML5 standards. Conditionals use ternary operators instead of if statements where possible combine sequential conditions that have the same result use mapping arrays instead of multiple if-statements when inspecting different values of the same variable for conditions that consist of multiple conditions, place each condition on its own line with the operator preceding the condition Arrays always use data_get() to access arrays, instead of accessing their elements directly. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/code-cleanliness","title":null},{"categories":null,"content":"Docs Starter Template | Classes Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects References Use Statements Use statements should be ordered alphabetically. Instantiation Where possible, classes should be injected via the constructor, allowing resolution from the CoI. Never user helper methods, or manual resolution via the app(\"...\") helper. Introspection and Type Casting Avoid introspection (checking the type of the class to determine the outcome of a condition). Avoid type casting. Both imply that logic should be encapsulated or refactored, likely resulting in rearranging or creation of classes. Final or Abstract, Never Neither Final classes cannot be extended. They are the final version of that class. Abstract classes need to be extended, and cannot be used alone. Avoid open-ended classes that are neither final nor abstract. Since you control the code, and it is unlikely to be used randomly by anyone else free-standing, and class that is not abstract should by default be final. Mutability TBD Classes should be immutable. If something is changed, they should return a new instance with the changed values. (Does this even make since in a Laravel context? I think this really only comes into play for Value Objects that are not models.) Naming Name classes after what they are, and not what they do. For example, the following is correct, and the later not so much: class Name { private $firstName; private $lastName; function print() { return \"{$this-&gt;firstName} {$this-&gt;lastName}\"; } } class NamePrinter { private $firstName; private $lastName; function print() { return \"{$this-&gt;firstName} {$this-&gt;lastName}\"; } } Contracts (Interfaces) Contracts aim to loosen coupling of objects in an application. It is important to remember that coupling is shifted from concrete implementations to abstract contracts (which have no logic, but only specify method interfaces). Contracts are not always necessary. They should be used with any class that is used in dependency injection or inversion of control containers. This lets us easily switch out implementations, especially in third-party-packages that might require some customization. Statics Avoid static classes. Classes are intended to be instantiated and be identifiable. Static classes do not have an identity are are not true objects, thus are a stow-away from the procedural era. Further, static classes and methods are little more than modern equivalents of GOTO statements, procedural in nature. OOP goes beyond that, the object is the defining principle, not the code. Static classes and methods are a crutch used to think procedurally under the guise of seeming object-oriented. We want our classes to be declarative, not imperative. From wikipedia: Declarative programming is a programming paradigm\u2014a style of building the structure and elements of computer programs\u2014that expresses the logic of a computation without describing its control flow. Imperative programming is a programming paradigm that uses statements that change a program&#39;s state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates. Static classes consisting of collections of static methods, also known as utility classes, are nothing more than a bunch of non-OOP helper methods grouped together. Constructors Prefer many constructors of many public methods, when possible. Use one primary constructor, along with multiple secondary (named) constructors that all make use of the primary constructor. Constructors should not include any functionality or logic, but merely assign values to object properties. If logic needs to be performed, this is an indication that the information passed in should actually be another object. The reason behind this is that any code in the constructor will be parsed every time an object is created, regardless if it is necessary or not. That can&#39;t be optimized. Instead of only assignments are handled in constructors, optimization can be controlled, and only the necessary code performed. Properties Keep classes to fewer than 4 properties where possible (Models are the exception). Avoid classes that do not encapsulate any data. TBD Avoid public properties where possible. Class properties should only be set through constructors and manipulated through methods. (Are getters and settings preferable over public properties -- what dangers are there to consider? What is the underlying reason this is considered such a bad thing?) Avoid setting properties to null. (And conversely avoid null-checks.) Methods Name methods according to what they return. Their names should be self-documenting. Methods that perform an action should be a verb, and return null. Methods that return objects should be nouns and named after the object they return (they can be prefixed with adjectives that help better describe the object being returned). Consider method names that are actions, but where an object is returned, like save(). In those cases, instead of returning null, return the object instance instead. Methods should only return one type of data, never mixed. Methods should have a declared parameter list, and not use a dynamic one (exceptions exist of course for magic methods). Getters and Setters Do not use getters and setters, other than the special methods used in models (getPropertyAttribute() and setPropertyAttribute($value)). &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/classes","title":null},{"categories":null,"content":"Docs Starter Template | Routes Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects \u2705 Do use resource routes that point to controllers whenever possible. \u26d4\ufe0f Do Not use closures in routes, as they cannot be cached in php artisan route:cache. APIs API routes should be within an API route namespace. API routes should use resource controllers: https:\/\/laravel.com\/docs\/5.2\/controllers#restful-resource-controllers. API route controllers should be named after the model they act on. API route controller methods should implement the restful naming scheme. API route controllers should only be responsible for a single model. Views View routes should have no namespace. View routes should use implicit controllers: https:\/\/laravel.com\/docs\/5.1\/controllers#implicit-controllers. View route controllers should be named after the blade view folder they are responsible for. View route controller methods should be named after the action they are responsible for. View route controllers should only be responsible for a single view type, but responsible for all sub-views, like: \/resources\/views\/reports\/index.blade.php \/resources\/views\/reports\/create.blade.php \/resources\/views\/reports\/show.blade.php etc... &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/routes","title":null},{"categories":null,"content":"Docs Starter Template | Blade Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Directives All blade directives shouls have a space between the directive and the parameters, mirroring the way PSR2 handles the equivalent PHP statements (if, for, etc.). &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/blade","title":null},{"categories":null,"content":"Docs Starter Template | NPM Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Install all npm packages that will be pre-compiled as dev requirements when using them in Laravel. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/npm","title":null},{"categories":null,"content":"Docs Starter Template Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Avoid the use of\u00a0null, both as a negative return value from a method, but also as default parameters. Instead of\u00a0null, use empty classes of the same type expected to be returned from methods (see NULL-Objects section). &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/null","title":null},{"categories":null,"content":"Docs Starter Template | Conventions Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects This file will be for brain-dumping rules that will later be sorted and broken out to one of the other pages where it fits in. This page will allow me to gather rules as we perform reviews and make sure they are documented. Try to avoid conditionals where possible (they increase cyclomatic complexity, which in turn increases mental and technical debt). \ud83c\udfc1 Never use\u00a0else or elseif\u00a0if you end up using a conditional. One alternative to conditionals is interpolation. Try to keep all code within the 80 character per line soft-limit. Absolutely always keep all code under 120 characters per line. However, exceeding 80 characters can be an indication of too deeply indented code. Consider refactoring out to one or more methods. Adhere to coding styles set forth in phpcs.xml, no exceptions. Code should not have any PHPMD, PHPCS, and PHPCPD warnings. (TBD\u00a0Try not to customize the rule sets, if at all possible.) Operators \ud83c\udfc1 all operators should be surrounded by 1 space, with the exception of operators at the beginning of the statement, such as the notoperator, in which case it does not have a preceding space: if (! $test) { \ud83d\udc40 if there is only a single condition in an if-statement, keep the if-statement condition portion on a single line, do not place the condition on its own line. \ud83c\udfc1 do not use inline if-statements. Blade empty lines around blade directives html attributes on their own lines, even if there is only one &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/conventions","title":null},{"categories":null,"content":"Docs Starter Template | Config &amp; Environment Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Always assign env variables to config properties in the config file that is most appropriate (or create a new config file it that makes more sense). Always refer to the config variable in your code, never reference\u00a0env('xxxxx', 'abc)\u00a0outside of config files. .env \u2705 Do store sensitive settings (passwords, API keys, etc.) in the\u00a0.env\u00a0file. \u26d4\ufe0f Do Not commit the\u00a0.env\u00a0file to version control (Git). use the\u00a0env()\u00a0command outside of config files, as it calls the cached config values, and not the actual values in the\u00a0.env\u00a0file. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/config-env","title":null},{"categories":null,"content":"Docs Starter Template | Migrations Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Each table should have its own migration file. Migrations should only change the database schema, and not manipulate data, unless directly necessary for the migration to run. Migrations should contain the definitive table definition in the up method, and only drop the table in the down method. Migrations should not be used to alter database structures, as this will prevent testing using in-memory SQLite databases. (See Seeders for this.) Primary Keys All primary keys should be defined as\u00a0$table-&gt;id();. Foreign Keys Foreign keys should be set on all fields that refer to another table. Foreign key fields should be defined as\u00a0$table-&gt;unsignedBigInteger(). Try to avoid manually naming the FK, instead let Laravel generate the name. This ensures consistent and predictable naming across the board. onDelete() Use\u00a0CASCADE\u00a0when the current table record should be deleted if the referring record is deleted. Use\u00a0SET NULL\u00a0when the current table record should be preserved, even if the referring record is deleted. If the foreign key field is nullable you should use\u00a0SET NULL. Use\u00a0RESTRICT\u00a0when the deletion of the referring record should be prevented if the current record exists. onUpdate() This should almost always be set to\u00a0CASCADE, meaning if the primary key of the referring record changes, this foreign key will update to retain the relationship. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/migrations","title":null},{"categories":null,"content":"Docs Starter Template | Eloquent Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Do not use raw queries for date calculations. This will potentially break queries when running tests in SQLite. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/eloquent","title":null},{"categories":null,"content":"Docs Starter Template | Controllers Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Purpose Controllers serve only two purposes: Process a specific request, handled by a request object (see below). Return an appropriate response, handled by a response object (see below). Controllers should contain no business logic. Instead, various types of business logic should be extracted out to: form submission processing should be extracted to Form Request objects. JSON responses should be extracted to Resource objects. other business logic should be extracted to Response objects. Structure Controllers should only contain RESTful methods. If additional methods seem to be needed, a new RESTful controller with an appropriate name should be created to satisfy that need. Single-Method Controllers If the controller only has a single method, use __invoke(). &lt;?php namespace App\\Http\\Controllers; use Illuminate\\View\\View; class WelcomeController extends Controller { public function __invoke() : View { return view('welcome'); } } Request Objects All controller methods that accept data should validate the incoming data using Request objects All controller methods that accept data should process the incoming data in a process() method that returns whatever object necessary to continue the logic in the controller method. For example: public function store(CreateReport $request) : RedirectResponse { $search = $request-&gt;process(); return redirect()-&gt;route('reports.show', ['addressSlug' =&gt; $search-&gt;address-&gt;slug]); } Response Objects Resource objects should be utilized to build up and return all data and objects required by the view to the view. &lt;?php namespace App\\Http\\Controllers\\Reports; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\Api\\Reports\\Event as Request; use App\\Http\\Responses\\Reports\\Events\\Csv; use Illuminate\\Contracts\\Support\\Responsable; class Event extends Controller { public function index(Request $request) : Responsable { return new Csv( $request-&gt;process(), 'CEEd Events Report.csv' ); } } &lt;?php namespace App\\Http\\Responses\\Reports\\Events; use App\\Http\\Resources\\BaseResourceCollection; use Illuminate\\Contracts\\Support\\Responsable; use Illuminate\\Http\\Response; use League\\Csv\\Writer; use SplTempFileObject; class Csv implements Responsable { protected $downloadFilename; protected $events; public function __construct( BaseResourceCollection $events, string $downloadFilename ) { $this-&gt;downloadFilename = $downloadFilename; $this-&gt;events = $events; } \/** * @SuppressWarnings(PHPMD.StaticAccess) * @SuppressWarnings(PHPMD.UnusedFormalParameter) *\/ public function toResponse($request) : Response { $csv = Writer::createFromFileObject(new SplTempFileObject); $csv-&gt;insertOne([ 'Season', 'Starts At', 'Ends At', 'Program', 'Venue', 'Moderators', 'Musicians', ]); $this-&gt;events-&gt;each(function ($event) use ($csv) { $csv-&gt;insertOne([ $event-&gt;seasonName, $event-&gt;starts_at, $event-&gt;ends_at, $event-&gt;programName, $event-&gt;venueName, $event-&gt;moderators-&gt;pluck('name')-&gt;implode(', '), $event-&gt;musicians-&gt;pluck('name')-&gt;implode(', '), ]); }); $headers = [ 'Content-Type' =&gt; 'text\/csv; charset=UTF-8', 'Content-Disposition' =&gt; \"attachment; filename=\\\"{$this-&gt;downloadFilename}\\\"\", ]; return response((string)$csv, 200, $headers); } } &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/controllers","title":null},{"categories":null,"content":"Docs Starter Template | Seeders Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Never reference other records by their primary key, if the key is not semantic. Always seed only one table per seeder. Always use models to seed, so that any reactivity in Laravel can be triggered. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/seeders","title":null},{"categories":null,"content":"Docs Starter Template | Models Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Eager Loading Avoid eager loading relationships in the protected $with = []; variable. Try to explicitly load relationships at the point they are used. Organization List use classes. List the public, protected, and private properties, each group in alphabetical order. List relationship methods. List getter and setter methods. List persistence methods. List protected methods. List private methods. Persistence Methods Laravel models are the de-facto persistence repository, especially in eloquent. Do not use the generic eloquent CRUD methods save(), update(), create(), delete(), etc. outside of the model. Instead create descriptive methods that explain exactly what is happening. This decouples the business domain from the persistence domain of the app, as well as makes code so much more humanly readable. For instance: instead of $user-&gt;save() create a method that handles a specific situation, like $agent-&gt;addListingInfo($listingInfo); and then handle all the data parsing and assignment in the method, at the end of which $this-&gt;save() is called to persist the changes. This pattern is not a Repository pattern, but instead an adaptation thereof for Laravel models. Laravel models already implement the repository patter in how they are build on top of Eloquent, so splitting out each model into multiple single-use-traits is an effort to maintain organization, while the other rules enforce the repository pattern of the model throughout the code-base. The benefits of this guide go deep beneath the surface, and at first glance may not be apparent: centralized place of maintenance in the attribute and query traits. deep performance optimization via centralized caching in the traits. This automatically ensures that relationship references are cached as well, for example when looping over a relationship collection. reduced technical dept, as queries and custom attributes are all contained in known centralized traits. This makes maintenance much easier when fixing or optimizing queries, as it is no longer necessary to inspect your entire codebase. reduced visual dept in models, as the custom parts are separated out into traits, keeping the model itself lean and to the point. adoption of better patterns: separating and centralizing queries helps DRY up your code, as well as force you to think more about how each query works and discover areas it can be optimized, by pulling it out of context, and looking at it on its own, without being distracted by the domain logic surrounding it. Structure Model class should only contain properties and relationship methods. All attribute methods should be extracted to an Attributes trait. All query methods should be extracted to traits: App |-Traits | |-Attributes | | \\-Book | | | \\-Queries | \\-Book | |-BaseModel \\-Book ``` ```php &lt;?php namespace App; use Illuminate\\Cache\\TaggableStore; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Support\\Collection; use Illuminate\\View\\View; use Laravel\\Scout\\Searchable; abstract class BaseModel extends Model { use Searchable; public static function boot() { parent::boot(); static::created(function () { self::flushCache(); }); static::deleted(function () { self::flushCache(); }); static::saved(function () { self::flushCache(); }); static::updated(function () { self::flushCache(); }); } public function cache(array $additionalTags = []) : View { if (cache()-&gt;getStore() instanceof TaggableStore) { $tags = array_push($additionalTags, str_slug(self::class)); $cache = $cache-&gt;tags($tags); } return $cache; } public static function flushCache() { cache()-&gt;tags([str_slug(self::class)]) -&gt;flush(); } } &lt;?php namespace App; use App\\Traits\\Attributes\\Contact as Attributes; use App\\Traits\\Queries\\Contact as Queries; use Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany; class Contact extends BaseModel { use Attributes; use Queries; protected $appends = [ 'searchKey', 'searchUrl', ]; protected $fillable = [ 'name', 'title', 'work_phone', 'mobile_phone', 'work_email', 'private_email', ]; public function contactTypes() : BelongsToMany { return $this-&gt;belongsToMany(ContactType::class); } } &lt;?php namespace App\\Traits\\Attributes; trait Contact { public function getGravatarAttribute() : string { $defaultAvatar = 'https:\/\/www.gravatar.com\/avatar\/?d=mm'; $workAvatar = 'https:\/\/www.gravatar.com\/avatar\/' . md5(strtolower(trim($this-&gt;work_email))) . '?d=mm'; $privateAvatar = 'https:\/\/www.gravatar.com\/avatar\/' . md5(strtolower(trim($this-&gt;private_email))) . '?d=mm'; if (md5(file_get_contents($workAvatar)) !== md5(file_get_contents($defaultAvatar))) { return $workAvatar; } if (md5(file_get_contents($privateAvatar)) !== md5(file_get_contents($defaultAvatar))) { return $privateAvatar; } return $defaultAvatar; } public function getSearchKeyAttribute() : string { return $this-&gt;name; } public function getSearchUrlAttribute() : string { return route('contacts.show', $this-&gt;getKey()); } } &lt;?php namespace App\\Traits\\Queries; use Illuminate\\Support\\Collection; trait Contact { public function getAll() : Collection { return cache()-&gt;tags([$this-&gt;classSlug]) -&gt;rememberForever(\"contact-{$this-&gt;id}-getAll\", function () { return $this-&gt;orderBy('name')-&gt;get(); }); } public function getByTypes(array $types) : Collection { $key = implode('-', $types); return cache()-&gt;tags([$this-&gt;classSlug, 'contact-type']) -&gt;rememberForever(\"contact-{$this-&gt;id}-getByTypes-{$key}\", function () use ($types) { return $this-&gt;with(['contactTypes' =&gt; function ($query) use ($types) { $query-&gt;whereIn('title', $types); }]) -&gt;orderBy('name') -&gt;get(); }); } } Eloquent Queries All Eloquent queries should be processed in dedicated methods within the queries trait of the model. The default getter methods provided by Eloquent should not be used anywhere outside of the model or its traits, with the exception of the following: find() findOrFail() Relationship Properties Do not query relationship properties on models directly. Instead expose the relationship property as a dynamic property in the model itself. This allows you to provide a default if the relationship does not exist, as well as limits interdependence of models to only the models themselves, and not through your code. For example, instead of $book-&gt;author-&gt;name, create a model attribute called authorName, then call that as $book-&gt;authorName in your code: &lt;?php namespace App; use App\\Traits\\Attributes\\Book as Attributes; class Book extends Model { use Attributes; public function author() : HasOne { return $this-&gt;hasOne(Author::class); } } &lt;?php namespace App\\Traits\\Attributes; trait Book { public function getAuthorNameAttribute() : string { return $this-&gt;author-&gt;name ?? ''; } } Naming Conventions For Properties or Methods with Certain Return Types boolean props or methods that check if a certain condition is true should be named has&lt;Condition in past tense&gt;. For Query Methods methods returning a single instance should be prefixed with find followed by the name of the model instance it returns, for example -&gt;findUserByName(string $name). methods returning a collection of instances should be prefixed with get followed by the name of the model instances is returns, for example -&gt;getUsersByType(string $type). Caching Caching should only be done using tags named after the model, and any specific parameters that make that query unique. Cache tags should be flushed when the corresponding model gets updated, saved, or deleted, so that subsequent responses will incorporate the changes. All queries in the model&#39;s query trait should be cached, as well those in attribute methods that access the database directly, and not through an already cached model query. Cached queries should be cached forever by default. However, if they incorporate timestamps or other temporal conditions, a sensible timeout should be set, depending on their use-case, typically between 1 and 15 minutes. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/models","title":null},{"categories":null,"content":"Docs Starter Template | Tests Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Always write unit and integration tests, testing for success and failure for each scenario. Only test public methods of classes. Write tests so that they cover all protected and private methods of the class, accessed through the public methods. If there are non-public methods that are not covered, they are either inaccessible, or the tests are comprehensive enough. If they are inaccessible, those methods should be removed. Tests should document the functionality of classes and their methods. Mock any external interfaces you do not control, and test for both successes and failures. Do not mock classes that you control. Unit Tests Write unite tests before implementing classes (only implement classes, never procedural code). When starting an app, start where you would start with writing code. The first test does not have to be elegant, or even correct. The most important thing is just to get started. Always do Red\/Green\/Refactor TDD. This means writing tests for the code you would like to see in an optimal world. Then make the failing test pass using the minimum amount of code. Write another test to expand on the first test, which again makes the existing code fail. Refactor your code to make the second test pass. Rinse and repeat until you have the minimum necessary functionality for your MVP (minimum viable product). During the red\/green\/refactor process, keep in mind that you need to develop from two different perspectives: When writing tests, keep the larger picture of the application and business domain in mind. When writing code to satisfy tests, only think about the test that needs to be satisfied. DO NOT THINK ABOUT BUSINESS LOGIC, ONLY FOCUS ON MAKING TESTS GREEN. Never add code that wont be used. Remove any code that is not used. Use cyclomatic complexity as a guide for the number of tests needed to achieve full test coverage of your code. As your tests get more specific, your code should become more generic. Goal of tests is to get as quickly as possible to &quot;Shameless Green&quot;, which means that no matter how ugly your code is, it satisfies all tests, thus is &quot;green&quot;. One of the principles of Shameless Green is that code is written for understanding, rather than extreme adherence to any and all patterns. The human is the focus. Consider Robert Martin&#39;s Transformation Priority Premise (https:\/\/8thlight.com\/blog\/uncle-bob\/2013\/05\/27\/TheTransformationPriorityPremise.html) when writing functional code to keep code complexity at a minimum. Try to opt for the highest ranked option. Abstract logic into methods only if they are used multiple times. Otherwise this might introduce mental debt and increase code complexity. Consider waiting to dry out duplicated code until after a few tests cover it. This way the correct abstraction might reveal itself, rather than prematurely abstracting it out incorrectly. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/tests","title":null},{"categories":null,"content":"Docs Starter Template | Patterns Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects NULL-Objects Do not use null-objects as a substitute for using\u00a0null\u00a0for negative results (btw, don't use\u00a0null\u00a0anywhere in code, as it is semantically void). Instead, add a\u00a0__toString()\u00a0method that returns an empty string for empty models, and non-empty value for valid objects. For example: public function __toString() { return \"{$this-&gt;getPrimaryKey()}\"; } This has the following benefits: Less cluttered code by eliminating noisy null-object classes (which serve no other purpose than to eliminate null-checks). Ease of maintenance. Adherence to single responsibility principle, in that a method only returns a single type of data. DRY (Don't Repeat Yourself) Do not apply the dry principle to code that deals with content, or even content itself. Apply DRY only to code that deals with logic. If you find wet code, but it doesn't appear that it can be dried out, you might have an architectural flaw. Restructuring or refactoring your classes could help. Only start drying out your code if you actually have duplication. DO NOT dry out code that isn't duplicated, as this leads to premature abstraction, and is almost certain to introduce both mental and technical debt. SOLID TBD Collections Use collections for all the things. TBD\u00a0Consider using classes as collection transformers: is there any intent to use more of magic method\u00a0__invoke\u00a0in future versions of Laravel? I found an interesting possibly to try things like:\u00a0$collection->map(new MyModelTransformer()); &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/patterns","title":null},{"categories":null,"content":"Docs Starter Template | Livewire Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Components Each livewire component needs to have a wire:key attribute that is immutable across page refreshes, but unique enough so that it never will conflict with another livewire component. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/livewire","title":null},{"categories":null,"content":"Docs Starter Template | Classes Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Catch errors and exceptions as soon as possible. Use type hinting and return types as one aspect toward achieving this. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/exceptions","title":null},{"categories":null,"content":"Docs Starter Template | Type Hinting Docs Starter Template Overview Laravel Eloquent Livewire Blade Seeders Migrations Controllers Classes NPM Models Routes Tests Config &amp; Environment Patterns Code Cleanliness Conventions Type Hinting &amp; Return Types Exceptions Null &amp; Null Objects Type hint all method parameters and return values. Type hints serve as documentation, making the code more fluent and readable. Type hints and return types prevent some logic errors from propagating, catching them as close as possible to their source. &copy; Tighten 2022. Built with Jigsaw and Tailwind CSS.","date":"Dec 25th, 2022","url":"https:\/\/valmar-holdings.github.io\/code-style-guide\/docs\/laravel\/type-hinting","title":null}]